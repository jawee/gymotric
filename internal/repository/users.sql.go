// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package repository

import (
	"context"
)

const createUserAndReturnId = `-- name: CreateUserAndReturnId :one
INSERT INTO users (
  id, username, password, created_on, updated_on, email
) VALUES (
  ?1, ?2, ?3, ?4, ?5, ?6
)
RETURNING id
`

type CreateUserAndReturnIdParams struct {
	ID        string      `json:"id"`
	Username  string      `json:"username"`
	Password  string      `json:"password"`
	CreatedOn string      `json:"created_on"`
	UpdatedOn string      `json:"updated_on"`
	Email     interface{} `json:"email"`
}

func (q *Queries) CreateUserAndReturnId(ctx context.Context, arg CreateUserAndReturnIdParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createUserAndReturnId,
		arg.ID,
		arg.Username,
		arg.Password,
		arg.CreatedOn,
		arg.UpdatedOn,
		arg.Email,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const emailExists = `-- name: EmailExists :one
SELECT count(*) from Users
WHERE email = ?1
`

func (q *Queries) EmailExists(ctx context.Context, email interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, emailExists, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getByEmail = `-- name: GetByEmail :one
SELECT id, username, password, created_on, updated_on, email, is_verified FROM users 
WHERE email = ?1
`

func (q *Queries) GetByEmail(ctx context.Context, email interface{}) (User, error) {
	row := q.db.QueryRowContext(ctx, getByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Email,
		&i.IsVerified,
	)
	return i, err
}

const getByUserId = `-- name: GetByUserId :one
SELECT id, username, password, created_on, updated_on, email, is_verified FROM users 
WHERE id = ?1
`

func (q *Queries) GetByUserId(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getByUserId, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Email,
		&i.IsVerified,
	)
	return i, err
}

const getByUsername = `-- name: GetByUsername :one
SELECT id, username, password, created_on, updated_on, email, is_verified FROM users 
WHERE username = ?1
`

func (q *Queries) GetByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Email,
		&i.IsVerified,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :execrows
UPDATE users
SET password = ?1, updated_on = ?2, email = ?3, is_verified = ?4
WHERE id = ?5
`

type UpdateUserParams struct {
	Password   string      `json:"password"`
	UpdatedOn  string      `json:"updated_on"`
	Email      interface{} `json:"email"`
	IsVerified bool        `json:"is_verified"`
	ID         string      `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateUser,
		arg.Password,
		arg.UpdatedOn,
		arg.Email,
		arg.IsVerified,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
