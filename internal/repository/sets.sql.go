// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sets.sql

package repository

import (
	"context"
)

const createSetAndReturnId = `-- name: CreateSetAndReturnId :one
INSERT INTO sets (
  id, repetitions, weight, exercise_id, created_on, updated_on, user_id
) VALUES (
  ?1, ?2, ?3, ?4, ?5, ?6, ?7
)
RETURNING id
`

type CreateSetAndReturnIdParams struct {
	ID          string  `json:"id"`
	Repetitions int64   `json:"repetitions"`
	Weight      float64 `json:"weight"`
	ExerciseID  string  `json:"exercise_id"`
	CreatedOn   string  `json:"created_on"`
	UpdatedOn   string  `json:"updated_on"`
	UserID      string  `json:"user_id"`
}

func (q *Queries) CreateSetAndReturnId(ctx context.Context, arg CreateSetAndReturnIdParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSetAndReturnId,
		arg.ID,
		arg.Repetitions,
		arg.Weight,
		arg.ExerciseID,
		arg.CreatedOn,
		arg.UpdatedOn,
		arg.UserID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteSetById = `-- name: DeleteSetById :execrows
DELETE FROM sets 
WHERE id = ?1
AND user_id = ?2
`

type DeleteSetByIdParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteSetById(ctx context.Context, arg DeleteSetByIdParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSetById, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllSets = `-- name: GetAllSets :many
SELECT id, repetitions, weight, created_on, updated_on, user_id, exercise_id, "foreign" FROM sets 
WHERE user_id = ?1
ORDER by id
`

func (q *Queries) GetAllSets(ctx context.Context, userID string) ([]Set, error) {
	rows, err := q.db.QueryContext(ctx, getAllSets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Set{}
	for rows.Next() {
		var i Set
		if err := rows.Scan(
			&i.ID,
			&i.Repetitions,
			&i.Weight,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.UserID,
			&i.ExerciseID,
			&i.Foreign,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSetById = `-- name: GetSetById :one
SELECT id, repetitions, weight, created_on, updated_on, user_id, exercise_id, "foreign" FROM sets 
WHERE id = ?1 AND user_id = ?2
`

type GetSetByIdParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetSetById(ctx context.Context, arg GetSetByIdParams) (Set, error) {
	row := q.db.QueryRowContext(ctx, getSetById, arg.ID, arg.UserID)
	var i Set
	err := row.Scan(
		&i.ID,
		&i.Repetitions,
		&i.Weight,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.UserID,
		&i.ExerciseID,
		&i.Foreign,
	)
	return i, err
}

const getSetsByExerciseId = `-- name: GetSetsByExerciseId :many
SELECT id, repetitions, weight, created_on, updated_on, user_id, exercise_id, "foreign" FROM sets 
WHERE exercise_id = ?1
AND user_id = ?2
`

type GetSetsByExerciseIdParams struct {
	ExerciseID string `json:"exercise_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) GetSetsByExerciseId(ctx context.Context, arg GetSetsByExerciseIdParams) ([]Set, error) {
	rows, err := q.db.QueryContext(ctx, getSetsByExerciseId, arg.ExerciseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Set{}
	for rows.Next() {
		var i Set
		if err := rows.Scan(
			&i.ID,
			&i.Repetitions,
			&i.Weight,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.UserID,
			&i.ExerciseID,
			&i.Foreign,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
